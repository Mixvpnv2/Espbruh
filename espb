-- Enhanced ESP Library with Head View Angles, Box Size Control, Glow Chams, and Death Fading
local ESP = {Players = {}}
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera

-- Default settings with constraints
ESP.Settings = {
    Enabled = true,
    Chams = false,
    GlowChams = true,
    Box = true,
    HealthBar = true,
    Text = true,
    Tracer = false,
    ViewAngle = false,
    HeadViewAngle = true,
    OffScreenArrow = false,
    Outline = false,
    BoldText = false,
    MaxDistance = 5000,
    ArrowRadius = 30,
    ArrowSize = 2,
    TextSize = 12,
    TextFont = 1,
    TeamCheck = false,
    TeamColor = true,
    BoxColor = Color3.new(1, 0, 0),
    ChamsColor = Color3.new(1, 0, 0),
    GlowChamsColor = Color3.new(1, 0.5, 0),
    TextColor = Color3.new(1, 1, 1),
    TracerColor = Color3.new(1, 1, 0),
    ViewAngleColor = Color3.new(0, 0.6, 1),
    HeadViewAngleColor = Color3.new(1, 0.5, 0),
    ArrowColor = Color3.new(1, 0, 0),
    HealthBarColor = Color3.new(0, 1, 0),
    BoxHeight = 6,
    BoxWidth = 20,
    BoxScale = 1.0,
    GlowIntensity = 5,
    GlowRadius = 20,
    GlowTransparency = 0.3,
    FadeDuration = 3 -- New: How long it takes for ESP to disappear after death
}

-- Font mapping
ESP.Fonts = {
    [1] = Enum.Font.Roboto,
    [2] = Enum.Font.Legacy,
    [3] = Enum.Font.SourceSans,
    [4] = Enum.Font.Code,
    [5] = Enum.Font.Gotham
}

-- Color presets for team (if team color is enabled)
ESP.Colors = {
    Ally = Color3.fromRGB(0, 255, 0),
    Enemy = Color3.fromRGB(255, 0, 0),
    Neutral = Color3.fromRGB(255, 255, 0)
}

-- Create ESP objects for a player
function ESP:Create(player)
    if self.Players[player] then return end
    
    local objects = {}
    self.Players[player] = {
        Object = objects, 
        Player = player,
        IsDead = false,
        DeathTime = 0,
        FadeProgress = 1 -- 1 = fully visible, 0 = fully invisible
    }
    
    -- Regular Chams Highlight
    objects.Highlight = Instance.new("Highlight")
    objects.Highlight.Name = player.Name.."_Chams"
    objects.Highlight.OutlineTransparency = 1
    objects.Highlight.FillTransparency = 0.5
    objects.Highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    objects.Highlight.Parent = game.CoreGui
    
    -- Glow Chams (improved)
    objects.GlowChams = Instance.new("Highlight")
    objects.GlowChams.Name = player.Name.."_GlowChams"
    objects.GlowChams.OutlineTransparency = 1
    objects.GlowChams.FillTransparency = 0.7
    objects.GlowChams.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    objects.GlowChams.Parent = game.CoreGui
    
    -- Box
    objects.Box = Drawing.new("Square")
    objects.Box.Thickness = 1
    objects.Box.Filled = false
    
    -- Health Bar
    objects.HealthBarOutline = Drawing.new("Square")
    objects.HealthBar = Drawing.new("Square")
    objects.HealthBar.Filled = true
    
    -- Text
    objects.Text = Drawing.new("Text")
    objects.Text.Center = true
    
    -- Tracer
    objects.Tracer = Drawing.new("Line")
    objects.Tracer.Thickness = 1
    
    -- View Angle (from torso)
    objects.ViewAngle = Drawing.new("Line")
    objects.ViewAngle.Thickness = 2
    
    -- Head View Angle
    objects.HeadViewAngle = Drawing.new("Line")
    objects.HeadViewAngle.Thickness = 2
    
    -- Off-screen arrow
    objects.Arrow = Drawing.new("Triangle")
    objects.Arrow.Filled = true
end

-- Update ESP settings with constraints
function ESP:UpdateSettings(newSettings)
    for setting, value in pairs(newSettings) do
        if self.Settings[setting] ~= nil then
            -- Apply constraints
            if setting == "ArrowRadius" then
                self.Settings[setting] = math.clamp(value, 1, 100)
            elseif setting == "ArrowSize" then
                self.Settings[setting] = math.clamp(value, 1, 5)
            elseif setting == "TextSize" then
                self.Settings[setting] = math.clamp(value, 1, 24)
            elseif setting == "TextFont" then
                self.Settings[setting] = math.clamp(value, 1, 5)
            elseif setting == "BoxHeight" then
                self.Settings[setting] = math.clamp(value, 1, 20)
            elseif setting == "BoxWidth" then
                self.Settings[setting] = math.clamp(value, 1, 20)
            elseif setting == "BoxScale" then
                self.Settings[setting] = math.clamp(value, 0.1, 3)
            elseif setting == "GlowIntensity" then
                self.Settings[setting] = math.clamp(value, 1, 10)
            elseif setting == "GlowRadius" then
                self.Settings[setting] = math.clamp(value, 5, 50)
            elseif setting == "GlowTransparency" then
                self.Settings[setting] = math.clamp(value, 0, 1)
            elseif setting == "FadeDuration" then
                self.Settings[setting] = math.clamp(value, 0.1, 10)
            else
                self.Settings[setting] = value
            end
        end
    end
end

-- Get team color based on settings
function ESP:GetTeamColor(player)
    if not self.Settings.TeamColor then 
        return self.Settings.BoxColor
    end
    
    local localPlayer = Players.LocalPlayer
    if not localPlayer then return self.Colors.Neutral end
    
    if player.Team == localPlayer.Team then
        return self.Colors.Ally
    else
        return self.Colors.Enemy
    end
end

-- Check if player should be visible
function ESP:ShouldShow(player)
    if not self.Settings.TeamCheck then return true end
    return player.Team ~= Players.LocalPlayer.Team
end

-- Update death status and start fade if needed
function ESP:UpdateDeathStatus(player, data, humanoid)
    local wasDead = data.IsDead
    local isDeadNow = humanoid.Health <= 0
    
    if isDeadNow and not wasDead then
        -- Player just died
        data.IsDead = true
        data.DeathTime = tick()
        data.FadeProgress = 1
    elseif not isDeadNow and wasDead then
        -- Player respawned
        data.IsDead = false
        data.FadeProgress = 1
    end
    
    -- Update fade progress if dead
    if data.IsDead then
        local timeSinceDeath = tick() - data.DeathTime
        data.FadeProgress = math.max(0, 1 - (timeSinceDeath / self.Settings.FadeDuration))
    end
end

-- Apply fade effect to drawing objects
function ESP:ApplyFadeEffect(objects, fadeProgress)
    local alpha = fadeProgress
    
    -- Apply transparency to drawing objects
    if objects.Box then
        objects.Box.Transparency = 1 - (alpha * 0.8)
    end
    if objects.HealthBar then
        objects.HealthBar.Transparency = 1 - (alpha * 0.8)
    end
    if objects.HealthBarOutline then
        objects.HealthBarOutline.Transparency = 1 - (alpha * 0.8)
    end
    if objects.Text then
        objects.Text.Transparency = 1 - (alpha * 0.8)
    end
    if objects.Tracer then
        objects.Tracer.Transparency = 1 - (alpha * 0.8)
    end
    if objects.ViewAngle then
        objects.ViewAngle.Transparency = 1 - (alpha * 0.8)
    end
    if objects.HeadViewAngle then
        objects.HeadViewAngle.Transparency = 1 - (alpha * 0.8)
    end
    if objects.Arrow then
        objects.Arrow.Transparency = 1 - (alpha * 0.8)
    end
    
    -- Apply transparency to highlights
    if objects.Highlight then
        objects.Highlight.FillTransparency = 0.5 + (0.5 * (1 - alpha))
    end
    if objects.GlowChams then
        objects.GlowChams.FillTransparency = 0.7 + (0.3 * (1 - alpha))
    end
end

-- Toggle ESP
function ESP:Toggle(state)
    self.Settings.Enabled = state
    if not state then
        -- Clear all ESP when disabling
        for _, data in pairs(self.Players) do
            if data.Object.Highlight then
                data.Object.Highlight.Enabled = false
            end
            if data.Object.GlowChams then
                data.Object.GlowChams.Enabled = false
            end
            data.Object.Box.Visible = false
            data.Object.HealthBar.Visible = false
            data.Object.HealthBarOutline.Visible = false
            data.Object.Text.Visible = false
            data.Object.Tracer.Visible = false
            data.Object.ViewAngle.Visible = false
            data.Object.HeadViewAngle.Visible = false
            data.Object.Arrow.Visible = false
        end
    end
end

-- Calculate proper bounding box with configurable size
function ESP:CalculateBoundingBox(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local head = character:FindFirstChild("Head")
    
    if not rootPart or not head then return nil end
    
    -- Use configurable box dimensions
    local height = self.Settings.BoxHeight * self.Settings.BoxScale
    local width = self.Settings.BoxWidth * self.Settings.BoxScale
    
    -- Calculate positions for box corners
    local top = rootPart.Position + Vector3.new(0, height/2, 0)
    local bottom = rootPart.Position - Vector3.new(0, height/2, 0)
    
    -- Convert to screen space
    local topScreenPos, topOnScreen = Camera:WorldToViewportPoint(top)
    local bottomScreenPos, bottomOnScreen = Camera:WorldToViewportPoint(bottom)
    
    if not topOnScreen and not bottomOnScreen then return nil end
    
    -- Calculate screen positions
    local topScreen = Vector2.new(topScreenPos.X, topScreenPos.Y)
    local bottomScreen = Vector2.new(bottomScreenPos.X, bottomScreenPos.Y)
    
    -- Calculate box size based on distance
    local distanceFactor = 1 / (topScreenPos.Z + 0.0001)
    local scaledWidth = width * distanceFactor * 100
    
    local size = Vector2.new(
        scaledWidth,
        (topScreen - bottomScreen).Magnitude
    )
    
    local position = Vector2.new(
        topScreen.X - size.X / 2,
        topScreen.Y
    )
    
    return position, size
end

-- Update glow chams properties (fixed)
function ESP:UpdateGlowChams(objects, character, teamColor, fadeProgress)
    if not objects.GlowChams then return end
    
    objects.GlowChams.Adornee = character
    objects.GlowChams.Enabled = self.Settings.GlowChams and fadeProgress > 0
    
    if self.Settings.GlowChams and fadeProgress > 0 then
        -- Enhanced glow effect
        local intensity = self.Settings.GlowIntensity / 10
        local baseColor = self.Settings.GlowChamsColor
        
        -- Create a more vibrant glow effect
        local glowColor = Color3.new(
            math.min(1, baseColor.R * intensity),
            math.min(1, baseColor.G * intensity),
            math.min(1, baseColor.B * intensity)
        )
        
        objects.GlowChams.FillColor = glowColor
        objects.GlowChams.FillTransparency = self.Settings.GlowTransparency + (0.3 * (1 - fadeProgress))
        
        -- Add outline for better glow effect
        objects.GlowChams.OutlineColor = glowColor
        objects.GlowChams.OutlineTransparency = 0.7 * (1 - fadeProgress)
    else
        objects.GlowChams.Enabled = false
    end
end

-- Update ESP visuals
function ESP:Update()
    if not self.Settings.Enabled then return end
    
    local cameraPos = Camera.CFrame.Position
    local localPlayer = Players.LocalPlayer
    
    for player, data in pairs(self.Players) do
        local character = player.Character
        local objects = data.Object
        
        if character and player ~= localPlayer and self:ShouldShow(player) then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local head = character:FindFirstChild("Head")
            local humanoid = character:FindFirstChild("Humanoid")
            
            if rootPart and humanoid and head then
                -- Update death status and fade progress
                self:UpdateDeathStatus(player, data, humanoid)
                
                local rootPos, rootOnScreen = Camera:WorldToViewportPoint(rootPart.Position)
                local headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position)
                local distance = (rootPart.Position - cameraPos).Magnitude
                local teamColor = self:GetTeamColor(player)
                
                if distance <= self.Settings.MaxDistance and data.FadeProgress > 0 then
                    -- Apply fade effect to all objects
                    self:ApplyFadeEffect(objects, data.FadeProgress)
                    
                    -- Regular Chams
                    if self.Settings.Chams then
                        objects.Highlight.Adornee = character
                        objects.Highlight.Enabled = true
                        objects.Highlight.FillColor = teamColor
                    else
                        objects.Highlight.Enabled = false
                    end
                    
                    -- Glow Chams (fixed)
                    self:UpdateGlowChams(objects, character, teamColor, data.FadeProgress)
                    
                    if rootOnScreen then
                        -- Calculate proper bounding box
                        local boxPos, boxSize = self:CalculateBoundingBox(character)
                        
                        if boxPos and boxSize then
                            -- Box
                            if self.Settings.Box then
                                objects.Box.Visible = true
                                objects.Box.Size = boxSize
                                objects.Box.Position = boxPos
                                objects.Box.Color = teamColor
                            else
                                objects.Box.Visible = false
                            end
                            
                            -- Health Bar
                            if self.Settings.HealthBar then
                                local healthPercent = humanoid.Health / humanoid.MaxHealth
                                local barHeight = boxSize.Y
                                local barWidth = 4
                                
                                -- Outline
                                objects.HealthBarOutline.Visible = self.Settings.Outline
                                objects.HealthBarOutline.Size = Vector2.new(barWidth, barHeight)
                                objects.HealthBarOutline.Position = boxPos - Vector2.new(6, 0)
                                objects.HealthBarOutline.Color = Color3.new(0, 0, 0)
                                
                                -- Fill
                                objects.HealthBar.Visible = true
                                objects.HealthBar.Size = Vector2.new(barWidth - 2, barHeight * healthPercent - 2)
                                objects.HealthBar.Position = objects.HealthBarOutline.Position + 
                                    Vector2.new(1, 1 + barHeight * (1 - healthPercent))
                                objects.HealthBar.Color = self.Settings.HealthBarColor:Lerp(
                                    Color3.new(1, 0, 0), 
                                    1 - healthPercent
                                )
                            else
                                objects.HealthBar.Visible = false
                                objects.HealthBarOutline.Visible = false
                            end
                            
                            -- Text
                            if self.Settings.Text then
                                objects.Text.Visible = true
                                local statusText = data.IsDead and "[DEAD] " or ""
                                objects.Text.Text = string.format("%s%s [%dm]", statusText, player.Name, math.floor(distance))
                                objects.Text.Position = Vector2.new(
                                    boxPos.X + boxSize.X / 2,
                                    boxPos.Y - 20
                                )
                                objects.Text.Size = self.Settings.TextSize
                                objects.Text.Font = self.Fonts[self.Settings.TextFont]
                                objects.Text.Color = self.Settings.TextColor
                            else
                                objects.Text.Visible = false
                            end
                        end
                        
                        -- Tracer
                        if self.Settings.Tracer then
                            objects.Tracer.Visible = true
                            objects.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                            objects.Tracer.To = Vector2.new(rootPos.X, rootPos.Y)
                            objects.Tracer.Color = self.Settings.TracerColor
                        else
                            objects.Tracer.Visible = false
                        end
                        
                        -- View Angle (from torso)
                        if self.Settings.ViewAngle then
                            objects.ViewAngle.Visible = true
                            local lookDir = rootPart.CFrame.LookVector * 5
                            local lookEnd = Camera:WorldToViewportPoint(rootPart.Position + lookDir)
                            objects.ViewAngle.From = Vector2.new(rootPos.X, rootPos.Y)
                            objects.ViewAngle.To = Vector2.new(lookEnd.X, lookEnd.Y)
                            objects.ViewAngle.Color = self.Settings.ViewAngleColor
                        else
                            objects.ViewAngle.Visible = false
                        end
                        
                        -- Head View Angle
                        if self.Settings.HeadViewAngle then
                            objects.HeadViewAngle.Visible = true
                            local headLookDir = head.CFrame.LookVector * 3
                            local headLookEnd = Camera:WorldToViewportPoint(head.Position + headLookDir)
                            objects.HeadViewAngle.From = Vector2.new(headPos.X, headPos.Y)
                            objects.HeadViewAngle.To = Vector2.new(headLookEnd.X, headLookEnd.Y)
                            objects.HeadViewAngle.Color = self.Settings.HeadViewAngleColor
                        else
                            objects.HeadViewAngle.Visible = false
                        end
                        
                        -- Hide off-screen elements
                        objects.Arrow.Visible = false
                    else
                        -- Off-screen arrow
                        if self.Settings.OffScreenArrow then
                            objects.Arrow.Visible = true
                            
                            local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                            local dir = (rootPart.Position - cameraPos).Unit
                            local angle = math.atan2(dir.Z, dir.X)
                            
                            local radius = self.Settings.ArrowRadius
                            local size = self.Settings.ArrowSize * 5
                            
                            local pos = center + Vector2.new(
                                math.cos(angle) * radius,
                                math.sin(angle) * radius
                            )
                            
                            local points = {
                                pos + Vector2.new(math.cos(angle) * size, math.sin(angle) * size),
                                pos + Vector2.new(math.cos(angle + 2.5) * size, math.sin(angle + 2.5) * size),
                                pos + Vector2.new(math.cos(angle - 2.5) * size, math.sin(angle - 2.5) * size)
                            }
                            
                            objects.Arrow.PointA = points[1]
                            objects.Arrow.PointB = points[2]
                            objects.Arrow.PointC = points[3]
                            objects.Arrow.Color = self.Settings.ArrowColor
                        else
                            objects.Arrow.Visible = false
                        end
                        
                        -- Hide on-screen elements
                        objects.Box.Visible = false
                        objects.HealthBar.Visible = false
                        objects.HealthBarOutline.Visible = false
                        objects.Text.Visible = false
                        objects.Tracer.Visible = false
                        objects.ViewAngle.Visible = false
                        objects.HeadViewAngle.Visible = false
                    end
                else
                    -- Out of range or fully faded - hide all
                    objects.Highlight.Enabled = false
                    objects.GlowChams.Enabled = false
                    objects.Box.Visible = false
                    objects.HealthBar.Visible = false
                    objects.HealthBarOutline.Visible = false
                    objects.Text.Visible = false
                    objects.Tracer.Visible = false
                    objects.ViewAngle.Visible = false
                    objects.HeadViewAngle.Visible = false
                    objects.Arrow.Visible = false
                end
            end
        else
            -- Player not valid - hide all
            if objects.Highlight then
                objects.Highlight.Enabled = false
            end
            if objects.GlowChams then
                objects.GlowChams.Enabled = false
            end
            objects.Box.Visible = false
            objects.HealthBar.Visible = false
            objects.HealthBarOutline.Visible = false
            objects.Text.Visible = false
            objects.Tracer.Visible = false
            objects.ViewAngle.Visible = false
            objects.HeadViewAngle.Visible = false
            objects.Arrow.Visible = false
        end
    end
end

-- Initialize ESP
function ESP:Init()
    -- Create ESP for existing players
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            self:Create(player)
        end
    end
    
    -- Set up new players
    Players.PlayerAdded:Connect(function(player)
        self:Create(player)
    end)
    
    -- Clean up leaving players
    Players.PlayerRemoving:Connect(function(player)
        local data = self.Players[player]
        if data then
            if data.Object.Highlight then
                data.Object.Highlight:Destroy()
            end
            if data.Object.GlowChams then
                data.Object.GlowChams:Destroy()
            end
            data.Object.Box:Remove()
            data.Object.HealthBar:Remove()
            data.Object.HealthBarOutline:Remove()
            data.Object.Text:Remove()
            data.Object.Tracer:Remove()
            data.Object.ViewAngle:Remove()
            data.Object.HeadViewAngle:Remove()
            data.Object.Arrow:Remove()
            self.Players[player] = nil
        end
    end)
    
    -- Start update loop
    RunService.Heartbeat:Connect(function()
        self:Update()
    end)
    
    return self
end

return ESP
