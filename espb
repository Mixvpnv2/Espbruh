-- Fixed ESP Library
local ESP = {Players = {}}
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera

-- Default settings
ESP.Settings = {
    Enabled = true,
    Chams = false,
    Box = true,
    HealthBar = true,
    Text = true,
    Tracer = false,
    ViewAngle = false,
    HeadViewAngle = true,
    OffScreenArrow = false,
    Outline = false,
    BoldText = false,
    MaxDistance = 5000,
    ArrowRadius = 30,
    ArrowSize = 2,
    TextSize = 12,
    TextFont = "Roboto",
    TeamCheck = false,
    TeamColor = true,
    BoxColor = Color3.new(1, 0, 0),
    ChamsColor = Color3.new(1, 0, 0),
    TextColor = Color3.new(1, 1, 1),
    TracerColor = Color3.new(1, 1, 0),
    ViewAngleColor = Color3.new(0, 0.6, 1),
    HeadViewAngleColor = Color3.new(1, 0.5, 0),
    ArrowColor = Color3.new(1, 0, 0),
    HealthBarColor = Color3.new(0, 1, 0),
    BoxHeight = 6,
    BoxWidth = 4,
    BoxScale = 1.0
}

-- Comprehensive font mapping
ESP.FontMap = {
    Roboto = Enum.Font.Roboto,
    Arial = Enum.Font.SourceSans,  -- Arial not available, using closest match
    ["Source Sans"] = Enum.Font.SourceSans,
    ["Source Sans Pro"] = Enum.Font.SourceSans,
    Code = Enum.Font.Code,
    Gotham = Enum.Font.Gotham,
    SciFi = Enum.Font.SciFi,
    Arcade = Enum.Font.Arcade,
    Fantasy = Enum.Font.Fantasy,
    Legacy = Enum.Font.Legacy,
    Bodoni = Enum.Font.SourceSans,  -- Fallbacks
    Helvetica = Enum.Font.SourceSans,
    Courier = Enum.Font.Code,
    Verdana = Enum.Font.SourceSans
}

-- Create ESP objects for a player
function ESP:Create(player)
    if self.Players[player] then return end
    
    local objects = {}
    self.Players[player] = {Object = objects, Player = player, Connections = {}}
    
    -- Chams Highlight
    objects.Highlight = Instance.new("Highlight")
    objects.Highlight.Name = player.Name.."_Chams"
    objects.Highlight.OutlineTransparency = 1
    objects.Highlight.FillTransparency = 0.5
    objects.Highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    objects.Highlight.Adornee = nil
    objects.Highlight.Parent = game:GetService("CoreGui")  -- Parent to CoreGui for safety
    
    -- Setup character connection
    local function setupCharacter(character)
        -- Clean up previous connections
        for _, conn in ipairs(objects.Connections) do
            conn:Disconnect()
        end
        objects.Connections = {}
        
        -- Connect to humanoid death
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            table.insert(objects.Connections, humanoid.Died:Connect(function()
                self:RemovePlayer(player)
            end))
            
            table.insert(objects.Connections, humanoid:GetPropertyChangedSignal("Health"):Connect(function()
                if humanoid.Health <= 0 then
                    self:RemovePlayer(player)
                end
            end))
        end
        
        -- Connect to character removal
        table.insert(objects.Connections, character.AncestryChanged:Connect(function(_, parent)
            if not parent then
                self:RemovePlayer(player)
            end
        end))
        
        -- Connect to character destruction
        table.insert(objects.Connections, character.Destroying:Connect(function()
            self:RemovePlayer(player)
        end))
    end
    
    -- Connect to character changes
    if player.Character then
        setupCharacter(player.Character)
    end
    
    local charAddedConn
    charAddedConn = player.CharacterAdded:Connect(function(character)
        setupCharacter(character)
    end)
    table.insert(objects.Connections, charAddedConn)
    
    -- Drawing objects
    objects.Box = Drawing.new("Square")
    objects.HealthBarOutline = Drawing.new("Square")
    objects.HealthBar = Drawing.new("Square")
    objects.Text = Drawing.new("Text")
    objects.Tracer = Drawing.new("Line")
    objects.ViewAngle = Drawing.new("Line")
    objects.HeadViewAngle = Drawing.new("Line")
    objects.Arrow = Drawing.new("Triangle")
    
    -- Initial setup
    objects.Box.Thickness = 1
    objects.Box.Filled = false
    objects.HealthBar.Filled = true
    objects.Text.Center = true
    objects.Arrow.Filled = true
    objects.ViewAngle.Thickness = 2
    objects.HeadViewAngle.Thickness = 2
    objects.Tracer.Thickness = 1
    
    -- Set initial visibility to false
    objects.Box.Visible = false
    objects.HealthBar.Visible = false
    objects.HealthBarOutline.Visible = false
    objects.Text.Visible = false
    objects.Tracer.Visible = false
    objects.ViewAngle.Visible = false
    objects.HeadViewAngle.Visible = false
    objects.Arrow.Visible = false
end

-- Remove player ESP
function ESP:RemovePlayer(player)
    local data = self.Players[player]
    if not data then return end
    
    -- Disconnect connections
    for _, conn in ipairs(data.Connections) do
        conn:Disconnect()
    end
    
    -- Destroy Highlight
    if data.Object.Highlight then
        data.Object.Highlight:Destroy()
    end
    
    -- Remove drawing objects
    data.Object.Box:Remove()
    data.Object.HealthBar:Remove()
    data.Object.HealthBarOutline:Remove()
    data.Object.Text:Remove()
    data.Object.Tracer:Remove()
    data.Object.ViewAngle:Remove()
    data.Object.HeadViewAngle:Remove()
    data.Object.Arrow:Remove()
    
    self.Players[player] = nil
end

-- Update ESP settings
function ESP:UpdateSettings(newSettings)
    for setting, value in pairs(newSettings) do
        if self.Settings[setting] ~= nil then
            -- Apply constraints
            if setting == "ArrowRadius" then
                self.Settings[setting] = math.clamp(value, 1, 100)
            elseif setting == "ArrowSize" then
                self.Settings[setting] = math.clamp(value, 1, 5)
            elseif setting == "TextSize" then
                self.Settings[setting] = math.clamp(value, 1, 24)
            elseif setting == "BoxHeight" then
                self.Settings[setting] = math.clamp(value, 1, 20)
            elseif setting == "BoxWidth" then
                self.Settings[setting] = math.clamp(value, 1, 20)
            elseif setting == "BoxScale" then
                self.Settings[setting] = math.clamp(value, 0.1, 3)
            else
                self.Settings[setting] = value
            end
        end
    end
end

-- Get font from setting
function ESP:GetFont()
    return self.FontMap[self.Settings.TextFont] or Enum.Font.Roboto
end

-- Get team color
function ESP:GetTeamColor(player)
    if not self.Settings.TeamColor then 
        return self.Settings.BoxColor
    end
    
    local localPlayer = Players.LocalPlayer
    if not localPlayer then return self.Settings.BoxColor end
    
    if player.Team == localPlayer.Team then
        return Color3.new(0, 1, 0)  -- Ally green
    else
        return Color3.new(1, 0, 0)  -- Enemy red
    end
end

-- Check if player should be visible
function ESP:ShouldShow(player)
    if not self.Settings.TeamCheck then return true end
    return player.Team ~= Players.LocalPlayer.Team
end

-- Toggle ESP
function ESP:Toggle(state)
    self.Settings.Enabled = state
    if not state then
        -- Clear all ESP when disabling
        for player, data in pairs(self.Players) do
            if data.Object.Highlight then
                data.Object.Highlight.Enabled = false
            end
            data.Object.Box.Visible = false
            data.Object.HealthBar.Visible = false
            data.Object.HealthBarOutline.Visible = false
            data.Object.Text.Visible = false
            data.Object.Tracer.Visible = false
            data.Object.ViewAngle.Visible = false
            data.Object.HeadViewAngle.Visible = false
            data.Object.Arrow.Visible = false
        end
    end
end

-- Calculate bounding box
function ESP:CalculateBoundingBox(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local head = character:FindFirstChild("Head")
    
    if not rootPart or not head then return nil end
    
    -- Use configurable box dimensions
    local height = self.Settings.BoxHeight * self.Settings.BoxScale
    local width = self.Settings.BoxWidth * self.Settings.BoxScale
    
    -- Calculate positions for box corners
    local top = rootPart.Position + Vector3.new(0, height/2, 0)
    local bottom = rootPart.Position - Vector3.new(0, height/2, 0)
    
    -- Convert to screen space
    local topScreenPos, topOnScreen = Camera:WorldToViewportPoint(top)
    local bottomScreenPos, bottomOnScreen = Camera:WorldToViewportPoint(bottom)
    
    if not topOnScreen and not bottomOnScreen then return nil end
    
    -- Calculate screen positions
    local topScreen = Vector2.new(topScreenPos.X, topScreenPos.Y)
    local bottomScreen = Vector2.new(bottomScreenPos.X, bottomScreenPos.Y)
    
    -- Calculate box size based on distance
    local distanceFactor = 1 / (topScreenPos.Z + 0.0001) -- Avoid division by zero
    local scaledWidth = width * distanceFactor * 100
    
    local size = Vector2.new(
        scaledWidth,
        (topScreen - bottomScreen).Magnitude
    )
    
    local position = Vector2.new(
        topScreen.X - size.X / 2,
        topScreen.Y
    )
    
    return position, size
end

-- Update ESP visuals
function ESP:Update()
    if not self.Settings.Enabled then return end
    
    local cameraPos = Camera.CFrame.Position
    local localPlayer = Players.LocalPlayer
    
    for player, data in pairs(self.Players) do
        local character = player.Character
        local objects = data.Object
        
        -- Skip if player is invalid or dead
        if not character or not character.Parent then
            self:RemovePlayer(player)
            goto continue
        end
        
        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then
            self:RemovePlayer(player)
            goto continue
        end
        
        if player ~= localPlayer and self:ShouldShow(player) then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local head = character:FindFirstChild("Head")
            
            if rootPart and head then
                local rootPos, rootOnScreen = Camera:WorldToViewportPoint(rootPart.Position)
                local headPos, headOnScreen = Camera:WorldToViewportPoint(head.Position)
                local distance = (rootPart.Position - cameraPos).Magnitude
                local teamColor = self:GetTeamColor(player)
                
                if distance <= self.Settings.MaxDistance then
                    -- Chams
                    if self.Settings.Chams then
                        objects.Highlight.Adornee = character
                        objects.Highlight.Enabled = true
                        objects.Highlight.FillColor = teamColor
                        objects.Highlight.OutlineColor = Color3.new(0, 0, 0)
                    else
                        objects.Highlight.Enabled = false
                    end
                    
                    if rootOnScreen then
                        -- Calculate proper bounding box
                        local boxPos, boxSize = self:CalculateBoundingBox(character)
                        
                        if boxPos and boxSize then
                            -- Box
                            if self.Settings.Box then
                                objects.Box.Visible = true
                                objects.Box.Size = boxSize
                                objects.Box.Position = boxPos
                                objects.Box.Color = teamColor
                            else
                                objects.Box.Visible = false
                            end
                            
                            -- Health Bar
                            if self.Settings.HealthBar then
                                local healthPercent = humanoid.Health / humanoid.MaxHealth
                                local barHeight = boxSize.Y
                                local barWidth = 4
                                
                                -- Outline
                                objects.HealthBarOutline.Visible = self.Settings.Outline
                                objects.HealthBarOutline.Size = Vector2.new(barWidth, barHeight)
                                objects.HealthBarOutline.Position = boxPos - Vector2.new(6, 0)
                                objects.HealthBarOutline.Color = Color3.new(0, 0, 0)
                                
                                -- Fill
                                objects.HealthBar.Visible = true
                                objects.HealthBar.Size = Vector2.new(barWidth - 2, barHeight * healthPercent - 2)
                                objects.HealthBar.Position = objects.HealthBarOutline.Position + 
                                    Vector2.new(1, 1 + barHeight * (1 - healthPercent))
                                objects.HealthBar.Color = self.Settings.HealthBarColor:Lerp(
                                    Color3.new(1, 0, 0), 
                                    1 - healthPercent
                                )
                            else
                                objects.HealthBar.Visible = false
                                objects.HealthBarOutline.Visible = false
                            end
                            
                            -- Text
                            if self.Settings.Text then
                                objects.Text.Visible = true
                                objects.Text.Text = string.format("%s [%dm]", player.Name, math.floor(distance))
                                objects.Text.Position = Vector2.new(
                                    boxPos.X + boxSize.X / 2,
                                    boxPos.Y - 20
                                )
                                objects.Text.Size = self.Settings.TextSize
                                objects.Text.Font = self:GetFont()
                                objects.Text.Color = self.Settings.TextColor
                            else
                                objects.Text.Visible = false
                            end
                        end
                        
                        -- Tracer
                        if self.Settings.Tracer then
                            objects.Tracer.Visible = true
                            objects.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                            objects.Tracer.To = Vector2.new(rootPos.X, rootPos.Y)
                            objects.Tracer.Color = self.Settings.TracerColor
                        else
                            objects.Tracer.Visible = false
                        end
                        
                        -- View Angle (from torso)
                        if self.Settings.ViewAngle then
                            objects.ViewAngle.Visible = true
                            local lookDir = rootPart.CFrame.LookVector * 5
                            local lookEnd = Camera:WorldToViewportPoint(rootPart.Position + lookDir)
                            if lookEnd then
                                objects.ViewAngle.From = Vector2.new(rootPos.X, rootPos.Y)
                                objects.ViewAngle.To = Vector2.new(lookEnd.X, lookEnd.Y)
                                objects.ViewAngle.Color = self.Settings.ViewAngleColor
                            end
                        else
                            objects.ViewAngle.Visible = false
                        end
                        
                        -- Head View Angle
                        if self.Settings.HeadViewAngle then
                            objects.HeadViewAngle.Visible = true
                            local headLookDir = head.CFrame.LookVector * 3
                            local headLookEnd = Camera:WorldToViewportPoint(head.Position + headLookDir)
                            if headLookEnd then
                                objects.HeadViewAngle.From = Vector2.new(headPos.X, headPos.Y)
                                objects.HeadViewAngle.To = Vector2.new(headLookEnd.X, headLookEnd.Y)
                                objects.HeadViewAngle.Color = self.Settings.HeadViewAngleColor
                            end
                        else
                            objects.HeadViewAngle.Visible = false
                        end
                        
                        -- Hide off-screen elements
                        objects.Arrow.Visible = false
                    else
                        -- Off-screen arrow
                        if self.Settings.OffScreenArrow then
                            objects.Arrow.Visible = true
                            
                            local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                            local dir = (rootPart.Position - cameraPos).Unit
                            local angle = math.atan2(dir.Z, dir.X)
                            
                            local radius = self.Settings.ArrowRadius
                            local size = self.Settings.ArrowSize * 5
                            
                            local pos = center + Vector2.new(
                                math.cos(angle) * radius,
                                math.sin(angle) * radius
                            )
                            
                            local points = {
                                pos + Vector2.new(math.cos(angle) * size, math.sin(angle) * size),
                                pos + Vector2.new(math.cos(angle + 2.5) * size, math.sin(angle + 2.5) * size),
                                pos + Vector2.new(math.cos(angle - 2.5) * size, math.sin(angle - 2.5) * size)
                            }
                            
                            objects.Arrow.PointA = points[1]
                            objects.Arrow.PointB = points[2]
                            objects.Arrow.PointC = points[3]
                            objects.Arrow.Color = self.Settings.ArrowColor
                        else
                            objects.Arrow.Visible = false
                        end
                        
                        -- Hide on-screen elements
                        objects.Box.Visible = false
                        objects.HealthBar.Visible = false
                        objects.HealthBarOutline.Visible = false
                        objects.Text.Visible = false
                        objects.Tracer.Visible = false
                        objects.ViewAngle.Visible = false
                        objects.HeadViewAngle.Visible = false
                    end
                else
                    -- Out of range - hide all
                    objects.Highlight.Enabled = false
                    objects.Box.Visible = false
                    objects.HealthBar.Visible = false
                    objects.HealthBarOutline.Visible = false
                    objects.Text.Visible = false
                    objects.Tracer.Visible = false
                    objects.ViewAngle.Visible = false
                    objects.HeadViewAngle.Visible = false
                    objects.Arrow.Visible = false
                end
            else
                -- Missing parts - hide all
                objects.Highlight.Enabled = false
                objects.Box.Visible = false
                objects.HealthBar.Visible = false
                objects.HealthBarOutline.Visible = false
                objects.Text.Visible = false
                objects.Tracer.Visible = false
                objects.ViewAngle.Visible = false
                objects.HeadViewAngle.Visible = false
                objects.Arrow.Visible = false
            end
        else
            -- Player not valid - hide all
            objects.Highlight.Enabled = false
            objects.Box.Visible = false
            objects.HealthBar.Visible = false
            objects.HealthBarOutline.Visible = false
            objects.Text.Visible = false
            objects.Tracer.Visible = false
            objects.ViewAngle.Visible = false
            objects.HeadViewAngle.Visible = false
            objects.Arrow.Visible = false
        end
        
        ::continue::
    end
end

-- Initialize ESP
function ESP:Init()
    -- Create ESP for existing players
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer then
            self:Create(player)
        end
    end
    
    -- Set up new players
    Players.PlayerAdded:Connect(function(player)
        if player ~= Players.LocalPlayer then
            self:Create(player)
        end
    end)
    
    -- Clean up leaving players
    Players.PlayerRemoving:Connect(function(player)
        self:RemovePlayer(player)
    end)
    
    -- Start update loop
    RunService.Heartbeat:Connect(function()
        self:Update()
    end)
    
    return self
end

return ESP
